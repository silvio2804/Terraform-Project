---
- name: Chaos Experiment & PostgreSQL Recovery (External File Strategy)
  hosts: master
  gather_facts: no
  vars:
    # --- Configurazione Generale ---
    scenario_id: "sc-postgres-crash-recov-01"
    namespace: "default"
    
    # --- Configurazione File Chaos ---
    # Percorso del file SULLA TUA MACCHINA (dove lanci ansible)
    local_chaos_file: "./postgres-chaos.yaml"
    # Percorso dove verrÃ  copiato SUL SERVER REMOTO
    remote_chaos_file: "/tmp/postgres-chaos.yaml"
    
    # --- Configurazione Metrics (Textfile Collector) ---
    metrics_dir: "/var/lib/node_exporter/textfile_collector"
    metrics_file: "chaos_experiment.prom"
    
    # --- Configurazione DB ---
    postgres_deployment: "postgres-db"
    postgres_label: "app=postgres"
    db_user: "postgres"
    db_name: "ehr"
    
    # --- Configurazione Backup/Restore ---
    backup_file: "/tmp/backup_ehr_clean.sql"
    pvc_manifest: "~/nfs" 

  tasks:

    # ==============================================================================
    # PREPARAZIONE
    # ==============================================================================
    - name: Ensure Textfile Collector directory exists
      file:
        path: "{{ metrics_dir }}"
        state: directory
        mode: '0777'
      become: yes

    # ==============================================================================
    # FASE 1: START DELL'ESPERIMENTO
    # ==============================================================================
    - name:  Mark Experiment START
      copy:
        dest: "{{ metrics_dir }}/{{ metrics_file }}"
        content: |
          # HELP experiment_status Stato corrente dell'esperimento (1=running)
          # TYPE experiment_status gauge
          experiment_status{scenario="{{ scenario_id }}"} 1
          experiment_event{scenario="{{ scenario_id }}",phase="start"} {{ lookup('pipe', 'date +%s') }}
        mode: '0644'

    # ==============================================================================
    # FASE 2: INIEZIONE DEL FAULT (Da file esterno)
    # ==============================================================================
    
    # 1. Copiamo il file dal controller Ansible al nodo Master
    - name: Copy Chaos configuration to remote
      copy:
        src: "{{ local_chaos_file }}"
        dest: "{{ remote_chaos_file }}"
        mode: '0644'

    # 2. Applichiamo il file
    - name:  Inject Chaos (Pod Kill)
      shell: kubectl apply -f {{ remote_chaos_file }}

    - name: Wait for Fault impact
      pause:
        seconds: 30

    - name: Clean up Chaos Experiment
      shell: kubectl delete -f {{ remote_chaos_file }}
      ignore_errors: yes

    # ==============================================================================
    # FASE 3: RECOVERY (Strategia Clean / Tabula Rasa)
    # ==============================================================================
    - name: Mark Recovery START
      shell: |
        echo 'experiment_event{scenario="{{ scenario_id }}",phase="recovery_start"} '$(date +%s) >> {{ metrics_dir }}/{{ metrics_file }}
        echo 'recovery_status{scenario="{{ scenario_id }}"} 1' >> {{ metrics_dir }}/{{ metrics_file }}

    # 3.1: Stop del DB
    - name: Scale down PostgreSQL
      shell: kubectl scale deploy {{ postgres_deployment }} --replicas=0 -n {{ namespace }}

    - name: Wait for DB pod termination
      shell: kubectl wait pod -l {{ postgres_label }} -n {{ namespace }} --for=delete --timeout=120s
      ignore_errors: yes

    # 3.2: Pulizia Dati
    - name: Delete PostgreSQL PVC
      shell: kubectl delete pvc postgres-pvc -n {{ namespace }}
      ignore_errors: yes

    # 3.3: Ricreazione Infrastruttura
    - name: Recreate PostgreSQL PVC
      shell: kubectl apply -f {{ pvc_manifest }}

    - name: Wait for PVC binding
      shell: kubectl wait pvc postgres-pvc -n {{ namespace }} --for=jsonpath='{.status.phase}'=Bound --timeout=60s
      ignore_errors: yes 

    - name: Scale up PostgreSQL deployment
      shell: kubectl scale deploy {{ postgres_deployment }} --replicas=1 -n {{ namespace }}

    - name: Wait for PostgreSQL pod ready
      shell: kubectl wait pod -l {{ postgres_label }} -n {{ namespace }} --for=condition=Ready --timeout=180s

    # ==============================================================================
    # FASE 4: RESTORE DEI DATI
    # ==============================================================================
    - name: Get new PostgreSQL pod name
      shell: kubectl get pod -l {{ postgres_label }} -n {{ namespace }} -o jsonpath='{.items[0].metadata.name}'
      register: postgres_pod

    - name: Restore PostgreSQL dump
      shell: |
        cat {{ backup_file }} | \
        kubectl exec -i {{ postgres_pod.stdout }} -n {{ namespace }} -- \
        psql -U {{ db_user }} {{ db_name }}

    # ==============================================================================
    # FASE 5: VERIFICA E FINE
    # ==============================================================================
    - name: Verify database integrity
      shell: |
        kubectl exec {{ postgres_pod.stdout }} -n {{ namespace }} -- \
        psql -U {{ db_user }} {{ db_name }} -c "SELECT count(*) FROM information_schema.tables;"
      register: db_check
      failed_when: db_check.rc != 0

    - name: Mark Experiment END
      shell: |
        # Append Timestamp fine
        echo 'experiment_event{scenario="{{ scenario_id }}",phase="end"} '$(date +%s) >> {{ metrics_dir }}/{{ metrics_file }}
        
        # Reset stati a 0 (Atomico)
        cp {{ metrics_dir }}/{{ metrics_file }} {{ metrics_dir }}/{{ metrics_file }}.tmp
        sed -i 's/experiment_status{scenario="{{ scenario_id }}"} 1/experiment_status{scenario="{{ scenario_id }}"} 0/' {{ metrics_dir }}/{{ metrics_file }}.tmp
        sed -i 's/recovery_status{scenario="{{ scenario_id }}"} 1/recovery_status{scenario="{{ scenario_id }}"} 0/' {{ metrics_dir }}/{{ metrics_file }}.tmp
        mv {{ metrics_dir }}/{{ metrics_file }}.tmp {{ metrics_dir }}/{{ metrics_file }}[silvio@ansible playbooks]$ 
