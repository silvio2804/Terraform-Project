---
- name: Chaos Experiment & PostgreSQL Recovery (Clean Strategy)
  hosts: master
  gather_facts: no
  vars:
    # --- Configurazione Generale ---
    scenario_id: "sc-postgres-crash-recov-01"
    namespace: "default"
    pushgateway_url: "http://prometheus-pushgateway:9091"
    
    # --- Configurazione DB ---
    postgres_deployment: "postgres-db"
    postgres_label: "app=postgres"  # Label usato per selezionare i pod
    db_user: "postgres"
    db_name: "ehr"
    
    # --- Configurazione Backup/Restore ---
    # Assicurati che questo file esista sulla macchina dove gira Ansible
    backup_file: "/tmp/backup_ehr_clean.sql"
    # Percorso del manifesto PVC originale (necessario per ricrearlo)
    pvc_manifest: "k8s/postgres-pvc.yaml" 

  tasks:

    # ==============================================================================
    # FASE 1: START DELL'ESPERIMENTO
    # ==============================================================================
    - name: Mark Experiment START
      shell: |
        echo "experiment_event{scenario=\"{{ scenario_id }}\",phase=\"start\"} $(date +%s)" | \
        curl --data-binary @- {{ pushgateway_url }}/metrics/job/chaos_experiment

    # ==============================================================================
    # FASE 2: INIEZIONE DEL FAULT (Chaos Mesh)
    # ==============================================================================
    - name: Inject Chaos (Pod Kill)
      shell: |
        cat <<EOF | kubectl apply -f -
        apiVersion: chaos-mesh.org/v1alpha1
        kind: PodChaos
        metadata:
          name: postgres-pod-kill-{{ scenario_id }}
          namespace: {{ namespace }}
        spec:
          action: pod-kill
          mode: one
          selector:
            labelSelectors:
              {{ postgres_label }}
          scheduler:
            cron: "@every 10m" # Lo uccide una volta, poi il cron lo rifarebbe dopo 10m
        EOF
      args:
        executable: /bin/bash

    - name: Wait for Fault impact (Simulate downtime/investigation)
      pause:
        seconds: 30

    # È CRUCIALE rimuovere il chaos prima di fare il recovery, altrimenti 
    # Chaos Mesh potrebbe uccidere il nuovo pod appena lo ricrei.
    - name: Clean up Chaos Experiment
      shell: kubectl delete podchaos postgres-pod-kill-{{ scenario_id }} -n {{ namespace }}
      ignore_errors: yes

    # ==============================================================================
    # FASE 3: RECOVERY (Strategia Clean / Tabula Rasa)
    # ==============================================================================
    - name: Mark Recovery START
      shell: |
        echo "recovery_event{scenario=\"{{ scenario_id }}\",phase=\"start\"} $(date +%s)" | \
        curl --data-binary @- {{ pushgateway_url }}/metrics/job/recovery

    # 3.1: Stop del DB
    - name: Scale down PostgreSQL (Isolate)
      shell: kubectl scale deploy {{ postgres_deployment }} --replicas=0 -n {{ namespace }}

    - name: Wait for DB pod termination
      shell: kubectl wait pod -l {{ postgres_label }} -n {{ namespace }} --for=delete --timeout=120s
      ignore_errors: yes

    # 3.2: Pulizia Dati (Tabula Rasa)
    - name: Delete PostgreSQL PVC (Wipe Data)
      shell: kubectl delete pvc postgres-pvc -n {{ namespace }}
      ignore_errors: yes

    # 3.3: Ricreazione Infrastruttura
    - name: Recreate PostgreSQL PVC
      shell: kubectl apply -f {{ pvc_manifest }}

    - name: Wait for PVC binding
      shell: kubectl wait pvc postgres-pvc -n {{ namespace }} --for=jsonpath='{.status.phase}'=Bound --timeout=60s
      # Nota: A volte il PVC resta 'Pending' finché non parte il Pod. 
      # Se usi StorageClass standard, potrebbe servire far partire prima il pod.
      # Se questo step fallisce, prova a spostarlo DOPO lo scale up.
      ignore_errors: yes 

    - name: Scale up PostgreSQL deployment
      shell: kubectl scale deploy {{ postgres_deployment }} --replicas=1 -n {{ namespace }}

    - name: Wait for PostgreSQL pod ready (New clean instance)
      shell: kubectl wait pod -l {{ postgres_label }} -n {{ namespace }} --for=condition=Ready --timeout=180s

    # ==============================================================================
    # FASE 4: RESTORE DEI DATI
    # ==============================================================================
    - name: Get new PostgreSQL pod name
      shell: kubectl get pod -l {{ postgres_label }} -n {{ namespace }} -o jsonpath='{.items[0].metadata.name}'
      register: postgres_pod

    # Usiamo 'kubectl exec -i' per passare il file locale direttamente al processo psql remoto
    # senza dover copiare fisicamente il file nel pod.
    - name: Restore PostgreSQL dump
      shell: |
        cat {{ backup_file }} | \
        kubectl exec -i {{ postgres_pod.stdout }} -n {{ namespace }} -- \
        psql -U {{ db_user }} {{ db_name }}

    # ==============================================================================
    # FASE 5: VERIFICA E FINE
    # ==============================================================================
    - name: Verify database integrity (Simple Check)
      shell: |
        kubectl exec {{ postgres_pod.stdout }} -n {{ namespace }} -- \
        psql -U {{ db_user }} {{ db_name }} -c "SELECT count(*) FROM information_schema.tables;"
      register: db_check
      failed_when: db_check.rc != 0

    - name: Mark Experiment END
      shell: |
        echo "experiment_event{scenario=\"{{ scenario_id }}\",phase=\"end\"} $(date +%s)" | \
        curl --data-binary @- {{ pushgateway_url }}/metrics/job/chaos_experiment